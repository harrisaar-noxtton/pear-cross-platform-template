# Pear Cross Platform Template

A cross-platform template that demonstrates how to use Pear by Holepunch with a single codebase for Expo, React Native, Web, and Desktop.

This template allows you to write code once and deploy it across multiple platforms: desktop (Windows, macOS, Linux), mobile (iOS, Android), and web.

### Prerequisites

- **Node.js version 22.14.0** 
- **Pear 1.18.0**

### Desktop

```bash
   node --version
   pear --v
   npm install
   npm run desktop
```

### Mobile

Haven’t tested this on iOS, but it should work the same way—just need to add the iOS script to package.json.

```bash
   node --version
   pear --v
   npm install
   npm run android
```

For debugging in another terminal:

```
adb logcat | grep "bare"
```

### Web

The fastest option for UI development. Doesn’t have Pear connection, but theoretically it’s possible to add it by creating a server that hosts Pear (perhaps in the future?)

```bash
   node --version
   pear --v
   npm install
   npm run web
```

### Desktop staging

```
pear -v
node --version
npm install
rm -rf dist-web
npm run build:web
pear stage dev
```

## How It Works

This project leverages Expo's web bundle capabilities to create a unified cross-platform application. Here's the architecture:

### Architecture Overview

Expo compiles your React Native code into a web-compatible bundle using `react-native-web`, which translates React Native components into standard web components (HTML, CSS, JS).

Pear serves generated static files.

Platform-specific components need to be either lazy loaded or conditionally excluded from rendering.

In this template `useWorklet` conditionally returns platform specific worklet hook. Since mobile is using `react-native-bare-kit`, it would not compile.

## Upsides of Using the Same Codebase for Both Platforms (Web/Desktop and Mobile)

You save a lot of time with no duplication and a single source of truth.

## Challenges/Shortcomings Compared to Platform-Specific Repos

Obviously, this template is not perfect and could be fine-tuned further. As we start developing, we may discover certain edge cases that need to be addressed.

All shortcomings and challenges are manageable.

1. **Build configuration is slightly more complex.** However, since build configuration is a one-time activity, it shouldn't affect the daily life of a developer. Developers can focus on code.

   Currently, there's a hacky solution for changing the package.json `main` attribute value. Perhaps future Pear configs will enable setting the main attribute directly in the Pear config instead of relying on the package.json `main` attribute value. Right now, this is handled with a script.

   The `dist-web` generated by the Expo bundler is not reusable out of the box and needs path fixes. These fixes are done with custom scripts located in the `scripts` folder.

2. **Pear desktop-specific features.** Features like using `<pear-ctrl></pear-ctrl>` currently require injection via script after build into index.html. There may be additional features like this that will need to be handled with a custom script in the future, once we determine the requirements.

3. **Platform-specific styles.** Features like hover states, which are not enabled on mobile. By default, the `react-native-web` compiler does not support them.

   **Solution one:** Use styled-components with platform-specific conditions. This can be set up in one location:

   ```tsx
   // WorkletDisplay.tsx
   // Example of how to use platform-specific styles.
   const styled = Platform.OS === 'web' 
     ? require('styled-components').default 
     : require('styled-components/native').default;

   const JoinWorkletButtonStyled = styled(Platform.OS === 'web' ? 'button' : TouchableOpacity)`
   ...
   ```
  **Solution two:** Add 'id' attributes to React components, then add a .css file to the dist-web bundle folder and reference it. However, adding classnames is more difficult, and this approach is not ideal.

  **Solution three:** There may be other dependencies we could use instead.

4. **Platform-specific features/components**: Usually, if a dependency is well-maintained, it already includes a good compiler for web bundles. For example, animation libraries often work on both Expo and web bundles. However, if some dependencies only work on one platform, the solution is to create two separate components (one for each platform) and conditionally choose which one to use based on the platform.

5. **Icons**: Expo Vector Icons won't work on desktop, react-icons won't work on mobile, and react-native-icons won't work on desktop. The solution I implemented was to create custom icon components like `PasteIcon.tsx`, where I use `import Svg, { Path, Rect } from 'react-native-svg';` to create new icons. This approach is supported on both platforms.
